'use strict'

const P = 11; // Change this to any big prime number. (150 digits at least)
const Q = 47; // Change this to any big prime number, different to P. (150 digits at least)
const R = (P - 1) * (Q - 1);
const N = P * Q;

/**
 * Public exponent
 *  
 * A public exponent of 3 minimizes the effort needed to verify a
 * signature.  Use of 3 as the public exponent is weak for
 * confidentiality uses since, if the same data can be collected
 * encrypted under three different keys with an exponent of 3 then,
 * using the Chinese Remainder Theorem [NETSEC], the original plain text
 * can be easily recovered.  If a key is known to be used only for
 * authentication, as is the case with DNSSEC, then an exponent of 3 is
 * acceptable. 
 *
 * Sources: 
 * RSA/SHA-1 SIGs and RSA KEYs in the Domain Name System (DNS)
 * https://tools.ietf.org/html/rfc3110
 */
var E = 3;

/**
 * D will be calculated d = e^1 mod (p-1) * (q-1)
 */
var D = 0;

/**
 * Calculates the extended Euclidean algorithm
 * 
 * Sources:
 * https://brilliant.org/wiki/extended-euclidean-algorithm/
 */
function extendendEuclidean(a, b) {

    var x = 0;
    var prevX = 1;
    var y = 1;
    var prevY = 0;
    var temp = 0,
        q = 0;

    while (b != 0) {
        q = Math.floor(a / b);
        temp = b;
        b = a % b;
        a = temp;
        temp = x;
        x = prevX - q * x;
        prevX = temp;
        temp = y;
        y = prevY - q * y;
        prevY = temp;
    }

    return prevY;

}

/**
 * 
 * Calculates the extended Euclidean algorithm and makes sure the value is positive
 * 
 * Sources:
 * https://brilliant.org/wiki/extended-euclidean-algorithm/
 * http://brandon.sternefamily.net/2005/05/rsa-algorithm/
 * https://stackoverflow.com/questions/46370666/while-attempting-to-calculate-d-for-an-rsa-implementation-d-always-comes-out-ne
 */

function positiveExtendendEuclidean(a, b) {

    var d = extendendEuclidean(a, b) % a;

    return d < 0 ? d + a : d;

}

/**
 * Computes the function powermod for very large integers x^p > 64 bits
 *
 * Sources: 
 * https://helloacm.com/compute-powermod-abn/
 * https://www.cs.drexel.edu/~introcs/Fa11/notes/10.1_Cryptography/RSAWorksheetv4d.html
 */
function powerMod(x, p, N) {

    var A = 1
    var m = p
    var t = x

    while (m > 0) {

        var k = Math.floor(m / 2);
        var r = m - 2 * k;

        if (r === 1) {
            A = (A * t) % N;
        }

        t = (t * t) % N;

        m = k;
    }

    return A
}


/**
 * Calculate the greatest common divisor non-recursively
 *
 * Sources: 
 * https://en.wikipedia.org/wiki/Greatest_common_divisor
 */
function gcd(a, n) {
    var b;

    //If a < n, swap the values and calculate again
    if (a < n) {
        return gcd(n, a);
    }

    //While the remainder > 0 keep getting values
    while (n != 0) {
        //Stores the value of n in b
        b = n;
        //Gets the reminder
        n = a % n;
        //Stores the candidate gdc
        a = b;
    }

    //Returns the GDC
    return a;
}

function _RSAEncrypt(input) {

    var cipheredText = '';

    if (gcd(E, R) === 1 && gcd(E, N) === 1) {

        //Travereses the input string
        for (var i = 0; i < input.length; i++) {

            //Each character of the string is warranted to be an UNICODE symbol represented as 16 bit integer
            //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt
            //powerMod mod is used to avoid having issues with the numeric precision of Javascript since it is limited
            //to 53 bits for integer values https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER
            cipheredText += String.fromCharCode(powerMod(input.charCodeAt(i), E, N));
        }

        //Becasue the resulting string is comprised of unicode characters, some are not printable thus we conver the string to base64
        return Buffer.from(cipheredText).toString('base64');

    } else {
        throw "E and R or E and N are not relative primes";
    }
}

function _RSADecrypt(input) {

    D = positiveExtendendEuclidean(R, E);

    if (gcd(D, R) === 1 && gcd(D, N) === 1) {

        //The base64 string is converted back to an Unicode string
        var cipheredText = Buffer.from(input, 'base64').toString();
        //We declare a variable to store the decoded message
        var plainText = '';

        for (var i = 0; i < cipheredText.length; i++) {
            //Each character is decoded and converted back to unicode
            plainText += String.fromCharCode(powerMod(cipheredText.charCodeAt(i), D, N));
        }

        return plainText;
    } else {
        throw "D and R or D and N are not relative primes";
    }
}

module.exports.RSAEncrypt = _RSAEncrypt;
module.exports.RSADecrypt = _RSADecrypt;