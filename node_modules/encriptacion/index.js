'use strict'

const P = 11; // Change this to any big prime number. (150 digits at least)
const Q = 47; // Change this to any big prime number, different to P. (150 digits at least)
const N = P * Q;
var E = 29;
var D = 349;

function remainder(a, n) {
    return a - n * (a % n);
}

/**
 * Computes the function powermod for very large integers x^p > 64 bits
 *
 * Sources: 
 * https://helloacm.com/compute-powermod-abn/
 * https://www.cs.drexel.edu/~introcs/Fa11/notes/10.1_Cryptography/RSAWorksheetv4d.html
 */
function powerMod(x, p, N) {

    var A = 1
    var m = p
    var t = x

    while (m > 0) {

        var k = Math.floor(m / 2);
        var r = m - 2 * k;

        if (r === 1) {
            A = (A * t) % N;
        }

        t = (t * t) % N;

        m = k;
    }

    return A
}

function _RSAEncrypt(input) {

    var cipheredText = '';

    //Travereses the input string
    for (var i = 0; i < input.length; i++) {
    
        //Each character of the string is warranted to be an UNICODE symbol represented as 16 bit integer
        //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt
        //powerMod mod is used to avoid having issues with the numeric precision of Javascript since it is limited
        //to 53 bits for integer values https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER
        cipheredText += String.fromCharCode(powerMod(input.charCodeAt(i), E, N));
    }

    //Becasue the resulting string is comprised of unicode characters, some are not printable thus we conver the string to base64
    return Buffer.from(cipheredText).toString('base64');
}

function _RSADecrypt(input) {

    //The base64 string is converted back to an Unicode string
    var cipheredText = Buffer.from(input, 'base64').toString();
    //We declare a variable to store the decoded message
    var plainText = '';

    for (var i = 0; i < cipheredText.length; i++) {
        //Each character is decoded and converted back to unicode
        plainText += String.fromCharCode(powerMod(cipheredText.charCodeAt(i), D, N));
    }

    return plainText;
}

function _GCD(a, n) {
    
    // Recursively calculate the greatest commond divider 
    if(n == 0){
        return a;
    } else {
        return _GCD(n, a%n);
    }
}

module.exports.RSAEncrypt = _RSAEncrypt;
module.exports.RSADecrypt = _RSADecrypt;
module.exports.GCD = _GCD;